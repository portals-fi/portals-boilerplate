/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/v2/tokens": {
    /** Returns a list of supported tokens by platform, including contextual information such as decimals, name, network, underlying tokens, price, TVL, etc. `Each filter type is concatenated with logical AND. Filter inputs that are arrays are logical OR.` */
    get: operations["SupportedController_getSupportedTokensV2"];
  };
  "/v1/networks": {
    /** Returns a list of supported networks */
    get: operations["SupportedController_getSupportedNetworks"];
  };
  "/v1/platforms/{network}": {
    /** Returns a list of supported platforms for network */
    get: operations["SupportedController_getSupportedPlatforms"];
  };
  "/v2/platforms": {
    /** Returns a list of enabled platforms */
    get: operations["SupportedController_getSupportedPlatformsV2"];
  };
  "/v1/portal/{network}": {
    /** Returns a validated, unsigned portal transaction that can be submitted to a node via ethers/web3. */
    get: operations["PortalController_portal"];
  };
  "/v1/portal/{network}/estimate": {
    /** Returns the expected and minimum amount to be received as a result of using the portal. Does not guarantee or check valid execution at this price. */
    get: operations["PortalController_estimatePortal"];
  };
  "/v1/portal/list/{network}/{platform}": {
    get: operations["PortalRegistryController_getPortal"];
  };
  "/v2/account": {
    /** Returns the current balance for ERC20 or network tokens for the `ownerAddress` if the balance is greater than 0 */
    get: operations["AccountController_getAccountV2"];
  };
  "/v1/approval/{network}": {
    /** Returns the current allowance for the appropriate target based on `buyToken`, in addition to an unsigned approval transaction for use by `takerAddress` if the returned property `shouldApprove` is true */
    get: operations["ApprovalController_approve"];
  };
  "/v1/farm/action": {
    get: operations["FarmController_action"];
  };
  "/v1/farm/approval": {
    get: operations["FarmController_approval"];
  };
  "/v1/farm/opportunities": {
    get: operations["FarmController_opportunities"];
  };
  "/v1/farm/account": {
    get: operations["FarmController_account"];
  };
  "/v1/farm/info": {
    get: operations["FarmController_info"];
  };
}

export interface components {
  schemas: {
    TokenResponseDto: {
      key: string;
      name: string;
      decimals: number;
      symbol: string;
      address: string;
      addresses: { [key: string]: unknown };
      platform: string;
      network: string;
      price: number;
      images: string[];
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      createdAt: string;
      tokens: string[];
      poolAddress: string;
      liquidity: number;
      image: string;
    };
    SupportedTokenResponseV2: {
      totalItems: number;
      pageItems: number;
      more: boolean;
      page: number;
      tokens: components["schemas"]["TokenResponseDto"][];
    };
    SupportedPlatformsV2Response: {
      platform: string;
      image: string;
      network: string;
    };
    PortalContext: {
      /** @description Network */
      network: string;
      /** @description Protocol id of the buyToken */
      protocolId: string;
      /** @description Address of sellToken */
      sellToken: string;
      /** @description Amount of sellToken to be sold */
      sellAmount: string;
      /** @description Address of intermediate token (used internally as a transition step to buyToken) */
      intermediateToken?: string;
      /** @description Address of buyToken */
      buyToken: string;
      /** @description Optimistic amount received assuming no slippage occurs */
      buyAmount: string;
      /** @description Minimum amount received assuming worst-case slippage */
      minBuyAmount: string;
      /** @description Address of the portal where the transaction will be sent to */
      target: string;
      /** @description Partner address that will receive commission from this transaction */
      partner: string;
      /** @description Address of the user who will pay the sellToken */
      takerAddress: string;
      /** @description Native network token value that will be sent with the transaction */
      value: string;
      /** @description Predicted gas limit (with buffer) for the transaction */
      gasLimit: string;
    };
    PortalBigNumber: {
      /** @description Type */
      type: string;
      /** @description Hex string */
      hex: string;
    };
    PopulatedPortalTransaction: {
      to: string;
      from?: string;
      data: string;
      /** @description BigNumber type */
      value?: components["schemas"]["PortalBigNumber"];
      /** @description BigNumber type */
      gasLimit?: components["schemas"]["PortalBigNumber"];
    };
    PortalResponse: {
      /** @description Contextual information about the transaction */
      context: components["schemas"]["PortalContext"];
      /** @description Transaction object to be signed */
      tx: components["schemas"]["PopulatedPortalTransaction"];
    };
    EstimatePortalResponse: {
      /** @description buyToken address */
      buyToken: string;
      /** @description Optimistic amount received assuming no slippage */
      buyAmount: string;
      /** @description Minimum amount received assuming worst-case slippage */
      minBuyAmount: string;
      /** @description Number of decimals for buyToken */
      buyTokenDecimals: number;
    };
    PortalListResponse: {
      in: string;
      out: string;
    };
    AccountResponseDto: {
      totalQueried?: number;
      balances: unknown[][];
    };
    ApprovalContext: {
      network: string;
      allowance?: string;
      approvalAmount?: string;
      shouldApprove: boolean;
      spender: string;
      gasLimit?: string;
    };
    ApprovalResponse: {
      context: components["schemas"]["ApprovalContext"];
      tx: components["schemas"]["PopulatedPortalTransaction"];
    };
    ActionResponseContext: {
      id: string;
      takerAddress: string;
      amount: string;
      action: string;
      platform: string;
      network: string;
      gasLimit?: string;
    };
    ActionResponse: {
      context: components["schemas"]["ActionResponseContext"];
      tx: components["schemas"]["PopulatedPortalTransaction"];
    };
    TokenAPR: {
      key: string;
      name: string;
      decimals: number;
      symbol: string;
      address: string;
      addresses: { [key: string]: unknown };
      platform: string;
      network: string;
      price: number;
      images: string[];
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      createdAt: string;
      tokens: string[];
      poolAddress: string;
      liquidity: number;
      image: string;
      apr: number;
    };
    APRResponse: {
      rewards: components["schemas"]["TokenAPR"][];
      total: number;
    };
    FarmOppResponse: {
      platform: string;
      image: string;
      apr: components["schemas"]["APRResponse"];
      token: components["schemas"]["TokenResponseDto"];
      network: string;
      tvl: number;
      id: string;
      name: string;
      index: number;
    };
    OppsResponse: {
      totalItems: number;
      pageItems: number;
      more: boolean;
      page: number;
      opps: components["schemas"]["FarmOppResponse"][];
      rewards: string[];
    };
    Claimable: {
      key: string;
      name: string;
      decimals: number;
      symbol: string;
      address: string;
      addresses: { [key: string]: unknown };
      platform: string;
      network: string;
      price: number;
      images: string[];
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      createdAt: string;
      tokens: string[];
      poolAddress: string;
      liquidity: number;
      image: string;
      amount: string;
    };
    BalancesResponse: {
      id: string;
      network: string;
      platform: string;
      amount: string;
      claimable: components["schemas"]["Claimable"][];
      token: components["schemas"]["TokenResponseDto"];
    };
    InfoResponse: {
      id: string;
      logo: string;
      name: string;
      url: string;
    };
  };
}

export interface operations {
  /** Returns a list of supported tokens by platform, including contextual information such as decimals, name, network, underlying tokens, price, TVL, etc. `Each filter type is concatenated with logical AND. Filter inputs that are arrays are logical OR.` */
  SupportedController_getSupportedTokensV2: {
    parameters: {
      query: {
        /** Optional search string that searches the contents for matches with token name (e.g. "balancer usdc usdt dai") */
        search?: string;
        /** Optional addresses to filter. Addresses must be in "[network]:[address]" format. e.g. `ethereum:0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48` */
        addresses?: string[];
        /** Optional comma-separated ids to filter */
        ids?: string;
        /** Optional platforms to filter from */
        platforms?: (
          | "native"
          | "basic"
          | "aavev2"
          | "aavev2wrapped"
          | "aavev3"
          | "apeswap"
          | "apeswap-lending"
          | "balancerv2"
          | "balancerv2boosted"
          | "bankerjoe"
          | "beethovenx"
          | "beefy"
          | "biswap"
          | "benqi"
          | "compound"
          | "convex"
          | "curve"
          | "geist"
          | "ironbank"
          | "mdex"
          | "mmfinance"
          | "nomiswap"
          | "pancakeswap"
          | "pangolin"
          | "pooltogether"
          | "quickswap"
          | "scream"
          | "shibaswap"
          | "spiritswap"
          | "spookyswap"
          | "stakedao"
          | "stakedao-vaults"
          | "stargate"
          | "sushiswap"
          | "thegranary"
          | "traderjoe"
          | "uniswapv2"
          | "venus"
          | "yearn"
          | "yearncrv"
          | "custom"
        )[];
        /** Optional networks to search from (ethereum, avalanche, etc.) (Default: all) */
        networks?: (
          | "ethereum"
          | "optimism"
          | "fantom"
          | "arbitrum"
          | "polygon"
          | "avalanche"
          | "bsc"
        )[];
        /** Optional minimum liquidity/TVL (in USD) available if asset is a pool */
        minLiquidity?: number;
        /** Optional maximum liquidity/TVL (in USD) available if asset is a pool */
        maxLiquidity?: number;
        /** Optional field to sort items by (Default: sorted by internal id) */
        sortBy?:
          | "key"
          | "decimals"
          | "name"
          | "symbol"
          | "updatedAt"
          | "price"
          | "liquidity"
          | "platform"
          | "network";
        /** Optional sort direction (Default: asc) */
        sortDirection?: "asc" | "desc";
        /** Optional number of items to return `(Max: 250)` */
        limit?: number;
        /** Optional page number for batch of items to return. Must also provide limit if page provided. `(Default: 0)` */
        page?: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SupportedTokenResponseV2"];
        };
      };
    };
  };
  /** Returns a list of supported networks */
  SupportedController_getSupportedNetworks: {
    parameters: {};
    responses: {
      200: {
        content: {
          "application/json": string[];
        };
      };
    };
  };
  /** Returns a list of supported platforms for network */
  SupportedController_getSupportedPlatforms: {
    parameters: {
      path: {
        /** The network to use (ethereum, avalanche, etc.) */
        network:
          | "ethereum"
          | "optimism"
          | "fantom"
          | "arbitrum"
          | "polygon"
          | "avalanche"
          | "bsc";
      };
    };
    responses: {
      200: {
        content: {
          "application/json": string[];
        };
      };
    };
  };
  /** Returns a list of enabled platforms */
  SupportedController_getSupportedPlatformsV2: {
    parameters: {};
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SupportedPlatformsV2Response"][];
        };
      };
    };
  };
  /** Returns a validated, unsigned portal transaction that can be submitted to a node via ethers/web3. */
  PortalController_portal: {
    parameters: {
      path: {
        /** The network to use (ethereum, avalanche, etc.) */
        network:
          | "ethereum"
          | "optimism"
          | "fantom"
          | "arbitrum"
          | "polygon"
          | "avalanche"
          | "bsc";
      };
      query: {
        /** The address of the owner of the `sellToken` */
        takerAddress: string;
        /** The ERC20 token address to spend */
        sellToken: string;
        /** The quantity of `sellToken` to spend */
        sellAmount: string;
        /** The ERC20 token address to buy (e.g. a Curve or Sushiswap pool, or a basic token like DAI). Use address(0) for the network token */
        buyToken: string;
        /** The maximum acceptable slippage for the portal. Must be a number between 0 and 1 (e.g. 0.005 for 0.5%) */
        slippagePercentage: number;
        /** The referral address */
        partner?: string;
        /** A valid secp256k1 signature of Permit by `takerAddress` encoded as r, s, v */
        signature?: string;
        /** When true, gas will be estimated and the portal transaction will be validated for success. */
        validate?: boolean;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PortalResponse"];
        };
      };
    };
  };
  /** Returns the expected and minimum amount to be received as a result of using the portal. Does not guarantee or check valid execution at this price. */
  PortalController_estimatePortal: {
    parameters: {
      path: {
        /** The network to use (ethereum, avalanche, etc.) */
        network:
          | "ethereum"
          | "optimism"
          | "fantom"
          | "arbitrum"
          | "polygon"
          | "avalanche"
          | "bsc";
      };
      query: {
        /** The ERC20 token address to spend */
        sellToken: string;
        /** The quantity of `sellToken` to spend */
        sellAmount: string;
        /** The ERC20 token address to buy (e.g. a Curve or Sushiswap pool, or a basic token like DAI). Use address(0) for the network token */
        buyToken: string;
        /** The maximum acceptable slippage for the portal. Must be a number between 0 and 1 (e.g. 0.005 for 0.5%) */
        slippagePercentage: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["EstimatePortalResponse"];
        };
      };
    };
  };
  PortalRegistryController_getPortal: {
    parameters: {
      path: {
        /** The network to use (ethereum, avalanche, etc.) */
        network:
          | "ethereum"
          | "optimism"
          | "fantom"
          | "arbitrum"
          | "polygon"
          | "avalanche"
          | "bsc";
        /** The platform to retrieve portal addresses for */
        platform:
          | "native"
          | "basic"
          | "aavev2"
          | "aavev2wrapped"
          | "aavev3"
          | "apeswap"
          | "apeswap-lending"
          | "balancerv2"
          | "balancerv2boosted"
          | "bankerjoe"
          | "beethovenx"
          | "beefy"
          | "biswap"
          | "benqi"
          | "compound"
          | "convex"
          | "curve"
          | "geist"
          | "ironbank"
          | "mdex"
          | "mmfinance"
          | "nomiswap"
          | "pancakeswap"
          | "pangolin"
          | "pooltogether"
          | "quickswap"
          | "scream"
          | "shibaswap"
          | "spiritswap"
          | "spookyswap"
          | "stakedao"
          | "stakedao-vaults"
          | "stargate"
          | "sushiswap"
          | "thegranary"
          | "traderjoe"
          | "uniswapv2"
          | "venus"
          | "yearn"
          | "yearncrv"
          | "custom";
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PortalListResponse"];
        };
      };
    };
  };
  /** Returns the current balance for ERC20 or network tokens for the `ownerAddress` if the balance is greater than 0 */
  AccountController_getAccountV2: {
    parameters: {
      query: {
        /** Required address of the owner of the ERC20 token whose balance is being queried */
        ownerAddress: string;
        /** Required list of networks to search from (ethereum, avalanche, etc.) */
        networks: (
          | "ethereum"
          | "optimism"
          | "fantom"
          | "arbitrum"
          | "polygon"
          | "avalanche"
          | "bsc"
        )[];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AccountResponseDto"];
        };
      };
    };
  };
  /** Returns the current allowance for the appropriate target based on `buyToken`, in addition to an unsigned approval transaction for use by `takerAddress` if the returned property `shouldApprove` is true */
  ApprovalController_approve: {
    parameters: {
      path: {
        /** The network to use (ethereum, avalanche, etc.) */
        network:
          | "ethereum"
          | "optimism"
          | "fantom"
          | "arbitrum"
          | "polygon"
          | "avalanche"
          | "bsc";
      };
      query: {
        /** The address of the owner of the ERC20 token */
        takerAddress: string;
        /** The ERC20 token address to spend */
        sellToken: string;
        /** The quantity of `sellToken` to spend */
        sellAmount: string;
        /** The ERC20 token address to buy (e.g. a Curve or Sushiswap pool, or a basic token like DAI). Use address(0) for the network token. */
        buyToken: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ApprovalResponse"];
        };
      };
    };
  };
  FarmController_action: {
    parameters: {
      query: {
        /** ID of the opportunity to perform the action on */
        id: string;
        /** User address */
        takerAddress: string;
        /** Amount of tokens */
        amount?: string;
        /** Type of action */
        action: "stake" | "unstake" | "claim" | "exit";
        /** When true, gas will be estimated and the transaction will be validated for success. */
        validate?: boolean;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ActionResponse"];
        };
      };
    };
  };
  FarmController_approval: {
    parameters: {
      query: {
        /** ID of the opportunity to perform the action on */
        id: string;
        /** User address */
        takerAddress: string;
        /** Amount of tokens */
        amount?: string;
        /** Type of action */
        action: "stake" | "unstake" | "claim" | "exit";
        /** When true, gas will be estimated and the transaction will be validated for success. */
        validate?: boolean;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ApprovalResponse"];
        };
      };
    };
  };
  FarmController_opportunities: {
    parameters: {
      query: {
        /** Optional search string that searches the contents for matches with token name (e.g. "balancer usdc usdt dai") */
        search?: string;
        /** Optional comma-separated unique ids of the opportunities to query */
        ids?: string;
        /** Optional comma-separated list of keys of the tokens to stake, in [network]:[address] format */
        tokens?: string;
        /** Optional comma-separated list of keys for the rewards to filter by (farm should reward at least one of these), in [network]:[address] format */
        rewards?: string;
        /** Optional comma-separated list of networks to select from (ethereum, avalanche, etc.) */
        networks?: string;
        /** Optional comma-separated list of platforms to select from */
        platforms?: string;
        /** Optional minimum liquidity/TVL (in USD) in the farm */
        minLiquidity?: number;
        /** Optional maximum liquidity/TVL (in USD) in the farm */
        maxLiquidity?: number;
        /** Field to sort items by (Default: apr) */
        sortBy: "platform" | "tvl" | "total" | "apr" | "name";
        /** Sort direction (Default: desc) */
        sortDirection: "asc" | "desc";
        /** Number of items to return `(Max: 250)` */
        limit: number;
        /** Page number for batch of items to return. Must also provide limit if page provided. `(Default: 0)` */
        page: number;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["OppsResponse"];
        };
      };
    };
  };
  FarmController_account: {
    parameters: {
      query: {
        /** User address */
        takerAddress: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BalancesResponse"][];
        };
      };
    };
  };
  FarmController_info: {
    parameters: {
      query: {
        /** Platform ID */
        platform?: string;
        /** If `true` return tokens and their opportunities in each farm */
        opportunities?: boolean;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["InfoResponse"][];
        };
      };
    };
  };
}

export interface external {}
